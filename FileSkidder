--// UI CREATION
local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Parent = game:GetService("Players").LocalPlayer:WaitForChild("PlayerGui")
ScreenGui.IgnoreGuiInset = true

local Frame = Instance.new("Frame")
Frame.Size = UDim2.new(0, 400, 0, 160)
Frame.Position = UDim2.new(-1, 0, 0.2, 0) -- Start off-screen left
Frame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
Frame.BorderSizePixel = 0
Frame.BackgroundTransparency = 0.1
Frame.Parent = ScreenGui

local UIStroke = Instance.new("UIStroke")
UIStroke.Thickness = 2
UIStroke.Color = Color3.fromRGB(255, 100, 100)
UIStroke.Parent = Frame

local UICorner = Instance.new("UICorner")
UICorner.CornerRadius = UDim.new(0, 10)
UICorner.Parent = Frame

local Text = Instance.new("TextLabel")
Text.Size = UDim2.new(1, -20, 0, 60)
Text.Position = UDim2.new(0, 10, 0, 10)
Text.BackgroundTransparency = 1
Text.Text = "you can skid this script just copy the url :3"
Text.TextColor3 = Color3.fromRGB(255, 255, 255)
Text.TextScaled = true
Text.Font = Enum.Font.FredokaOne
Text.Parent = Frame

local Yes = Instance.new("TextButton")
Yes.Size = UDim2.new(0.45, -10, 0, 40)
Yes.Position = UDim2.new(0.05, 0, 1, -50)
Yes.BackgroundColor3 = Color3.fromRGB(70, 200, 70)
Yes.Text = "Yes"
Yes.TextScaled = true
Yes.Font = Enum.Font.FredokaOne
Yes.Parent = Frame

local No = Instance.new("TextButton")
No.Size = UDim2.new(0.45, -10, 0, 40)
No.Position = UDim2.new(0.5, 0, 1, -50)
No.BackgroundColor3 = Color3.fromRGB(200, 70, 70)
No.Text = "No"
No.TextScaled = true
No.Font = Enum.Font.FredokaOne
No.Parent = Frame

Instance.new("UICorner", Yes)
Instance.new("UICorner", No)

--// DROP ANIMATION (from left)
Frame:TweenPosition(
    UDim2.new(0.05, 0, 0.2, 0),
    Enum.EasingDirection.Out,
    Enum.EasingStyle.Bounce,
    0.9,
    true
)

--// Clipboard URL
local URL = "https://discord.com/channels/1439818978309705842"

--// YES BUTTON: Copy + go upward + vanish
Yes.MouseButton1Click:Connect(function()
    if setclipboard then
        setclipboard(URL)
    end

    Text.Text = "Copied :<"
    Yes.Text = "âœ“"
    Yes.BackgroundColor3 = Color3.fromRGB(50, 150, 50)

    -- Upward vanish animation
    Frame:TweenPosition(
        UDim2.new(0.05, 0, -0.3, 0),
        Enum.EasingDirection.In,
        Enum.EasingStyle.Quad,
        0.6,
        true
    )

    -- Fade out
    for i = 1, 20 do
        Frame.BackgroundTransparency += 0.05
        Text.TextTransparency += 0.05
        Yes.TextTransparency += 0.05
        No.TextTransparency += 0.05
        task.wait(0.03)
    end

    ScreenGui:Destroy()
end)

--// NO BUTTON: Fade out normally
No.MouseButton1Click:Connect(function()
    for i = 1, 20 do
        Frame.BackgroundTransparency += 0.05
        Text.TextTransparency += 0.05
        Yes.TextTransparency += 0.05
        No.TextTransparency += 0.05
        task.wait(0.03)
    end
    ScreenGui:Destroy()
end)


local WindUI
do
    local ok, result = pcall(function()
        return require("./src/Init")
    end)
    if ok then
        WindUI = result
    else
        WindUI = loadstring(game:HttpGet("https://github.com/Footagesus/WindUI/releases/latest/download/main.lua"))()
    end
end
local executor = identifyexecutor() or getexecutorname() or "Unknown"
local badExecutors = {"Radius", "Nihon", "JJsploit"}
local isBadExecutor = false
for _, bad in ipairs(badExecutors) do
    if executor:lower():find(bad:lower()) then
        isBadExecutor = true
        break
    end
end
if isBadExecutor then
    local warningGui = Instance.new("ScreenGui")
    warningGui.Name = "DiabloWarningUI"
    warningGui.Parent = game.Players.LocalPlayer.PlayerGui
    warningGui.ResetOnSpawn = false
    local warningFrame = Instance.new("Frame")
    warningFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    warningFrame.BorderSizePixel = 0
    warningFrame.Position = UDim2.new(0.5, -200, 0.5, -100)
    warningFrame.Size = UDim2.new(0, 400, 0, 200)
    warningFrame.Parent = warningGui
    local UICornerWarning = Instance.new("UICorner")
    UICornerWarning.CornerRadius = UDim.new(0.1, 0)
    UICornerWarning.Parent = warningFrame
    local warningLabel = Instance.new("TextLabel")
    warningLabel.BackgroundTransparency = 1
    warningLabel.Position = UDim2.new(0, 0, 0.1, 0)
    warningLabel.Size = UDim2.new(1, 0, 0.8, 0)
    warningLabel.Font = Enum.Font.SourceSansBold
    warningLabel.TextColor3 = Color3.fromRGB(255, 0, 0)
    warningLabel.TextSize = 20
    warningLabel.TextWrapped = true
    warningLabel.Text = "your executor is not yet Supported Some Features may bugged out or wont work Change your executor for better capabilities"
    warningLabel.TextXAlignment = Enum.TextXAlignment.Center
    warningLabel.Parent = warningFrame
    wait(math.random(3, 5))
    warningGui:Destroy()
end
local loadingGui = Instance.new("ScreenGui")
loadingGui.Name = "DiabloLoadingUI"
loadingGui.Parent = game.Players.LocalPlayer.PlayerGui
loadingGui.ResetOnSpawn = false
local loadingFrame = Instance.new("Frame")
loadingFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
loadingFrame.BorderSizePixel = 0
loadingFrame.Position = UDim2.new(0.5, -150, 0.5, -75)
loadingFrame.Size = UDim2.new(0, 300, 0, 150)
loadingFrame.Parent = loadingGui
local UICornerLoading = Instance.new("UICorner")
UICornerLoading.CornerRadius = UDim.new(0.1, 0)
UICornerLoading.Parent = loadingFrame
local welcomeLabel = Instance.new("TextLabel")
welcomeLabel.BackgroundTransparency = 1
welcomeLabel.Position = UDim2.new(0, 0, 0.2, 0)
welcomeLabel.Size = UDim2.new(1, 0, 0.3, 0)
welcomeLabel.Font = Enum.Font.SourceSansBold
welcomeLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
welcomeLabel.TextSize = 24
welcomeLabel.Text = "Welcome to Diablo Hub"
welcomeLabel.TextXAlignment = Enum.TextXAlignment.Center
welcomeLabel.Parent = loadingFrame
local loadingLabel = Instance.new("TextLabel")
loadingLabel.BackgroundTransparency = 1
loadingLabel.Position = UDim2.new(0, 0, 0.5, 0)
loadingLabel.Size = UDim2.new(1, 0, 0.3, 0)
loadingLabel.Font = Enum.Font.SourceSansBold
loadingLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
loadingLabel.TextSize = 18
loadingLabel.Text = "Loading..."
loadingLabel.TextXAlignment = Enum.TextXAlignment.Center
loadingLabel.Parent = loadingFrame
local dotsCount = 0
spawn(function()
    while loadingGui.Parent do
        dotsCount = (dotsCount % 3) + 1
        loadingLabel.Text = "Loading" .. ("."):rep(dotsCount)
        wait(0.5)
    end
end)
wait(3)
loadingGui:Destroy()
local Window = WindUI:CreateWindow({
    Title = "YBA Script | Free Version",
    Icon = "cat",
    Author = "by Diablo",
    Folder = "yba_script",
    NewElements = true,
    HideSearchBar = false,
    OpenButton = {
        Title = "Open Diablo UI", -- can be changed
        CornerRadius = UDim.new(1,0), -- fully rounded
        StrokeThickness = 3, -- removing outline
        Enabled = true, -- enable or disable openbutton
        Draggable = true,
        OnlyMobile = false,
        Color = ColorSequence.new( -- gradient
            Color3.fromHex("#30FF6A"),
            Color3.fromHex("#e7ff2f")
        )
    }
})
Window:SetToggleKey(Enum.KeyCode.K)
local function parseJSON(luau_table, indent, level, visited)
    indent = indent or 2
    level = level or 0
    visited = visited or {}
    local currentIndent = string.rep(" ", level * indent)
    local nextIndent = string.rep(" ", (level + 1) * indent)
    if luau_table == nil then
        return "null"
    end
    local dataType = type(luau_table)
    if dataType == "table" then
        if visited[luau_table] then
            return "\"[Circular Reference]\""
        end
        visited[luau_table] = true
        local isArray = true
        local maxIndex = 0
        for k, _ in pairs(luau_table) do
            if type(k) == "number" and k > maxIndex then
                maxIndex = k
            end
            if type(k) ~= "number" or k <= 0 or math.floor(k) ~= k then
                isArray = false
                break
            end
        end
        local count = 0
        for _ in pairs(luau_table) do
            count = count + 1
        end
        if count ~= maxIndex and isArray then
            isArray = false
        end
        if count == 0 then
            return "{}"
        end
        if isArray then
            if count == 0 then
                return "[]"
            end
            local result = "[\n"
            for i = 1, maxIndex do
                result = result .. nextIndent .. parseJSON(luau_table[i], indent, level + 1, visited)
                if i < maxIndex then
                    result = result .. ","
                end
                result = result .. "\n"
            end
            result = result .. currentIndent .. "]"
            return result
        else
            local result = "{\n"
            local first = true
            local keys = {}
            for k in pairs(luau_table) do
                table.insert(keys, k)
            end
            table.sort(keys, function(a, b)
                if type(a) == type(b) then
                    return tostring(a) < tostring(b)
                else
                    return type(a) < type(b)
                end
            end)
            for _, k in ipairs(keys) do
                local v = luau_table[k]
                if not first then
                    result = result .. ",\n"
                else
                    first = false
                end
                if type(k) == "string" then
                    result = result .. nextIndent .. "\"" .. k .. "\": "
                else
                    result = result .. nextIndent .. "\"" .. tostring(k) .. "\": "
                end
                result = result .. parseJSON(v, indent, level + 1, visited)
            end
            result = result .. "\n" .. currentIndent .. "}"
            return result
        end
    elseif dataType == "string" then
        local escaped = luau_table:gsub("\\", "\\\\")
        escaped = escaped:gsub("\"", "\\\"")
        escaped = escaped:gsub("\n", "\\n")
        escaped = escaped:gsub("\r", "\\r")
        escaped = escaped:gsub("\t", "\\t")
        return "\"" .. escaped .. "\""
    elseif dataType == "number" then
        return tostring(luau_table)
    elseif dataType == "boolean" then
        return luau_table and "true" or "false"
    elseif dataType == "function" then
        return "\"function\""
    else
        return "\"" .. dataType .. "\""
    end
end
local function tableToClipboard(luau_table, indent)
    indent = indent or 4
    local jsonString = parseJSON(luau_table, indent)
    setclipboard(jsonString)
    return jsonString
end
local AboutTab = Window:Tab({
    Title = "About",
    Icon = "info",
})
local AboutSection = AboutTab:Section({
    Title = "Thank You",
})
AboutSection:Section({
    Title = "Thank you for using this script!",
    TextSize = 24,
    FontWeight = Enum.FontWeight.SemiBold,
})
AboutSection:Space()
AboutSection:Section({
    Title = "Tips",
    TextSize = 18,
    TextTransparency = .35,
    FontWeight = Enum.FontWeight.Medium,
})
AboutSection:Section({
    Title = "- Use Normal farming for safe play, AFK for faster but riskier.",
    TextSize = 18,
    TextTransparency = .35,
    FontWeight = Enum.FontWeight.Medium,
})
AboutSection:Section({
    Title = "- Sell worthless items regularly.",
    TextSize = 18,
    TextTransparency = .35,
    FontWeight = Enum.FontWeight.Medium,
})
AboutSection:Section({
    Title = "- Enable Boost Fps to avoid lagging.",
    TextSize = 18,
    TextTransparency = .35,
    FontWeight = Enum.FontWeight.Medium,
})
AboutSection:Space()
AboutSection:Section({
    Title = "Join our Discord for updates and support!",
    TextSize = 18,
})
AboutSection:Button({
    Title = "Copy Discord Link",
    Callback = function()
        setclipboard("https://discord.gg/GfKNNFm7")
        notify("Copied", "Discord link copied to clipboard!")
    end
})
AboutSection:Space()
AboutSection:Section({
    Title = "Credits",
    TextSize = 18,
    TextTransparency = .35,
    FontWeight = Enum.FontWeight.Medium,
})
AboutSection:Section({
    Title = "Forcass, Diablo, L4ve3",
    TextSize = 18,
    TextTransparency = .35,
    FontWeight = Enum.FontWeight.Medium,
})
local FarmingTab = Window:Tab({ Title = "Farming", Icon = "skull" })
local SellingTab = Window:Tab({ Title = "Selling", Icon = "dollar-sign" })
local VisualTab = Window:Tab({ Title = "Visual", Icon = "eye" })
local MiscTab = Window:Tab({ Title = "Misc", Icon = "zap" })
local AdjustTab = Window:Tab({ Title = "Adjust", Icon = "sliders-horizontal" })
local LevelFarmTab = Window:Tab({ Title = "Level Farm", Icon = "arrow-up" })
local TrollingTab = Window:Tab({ Title = "Trolling", Icon = "smile" })
local SettingsTab = Window:Tab({ Title = "Settings", Icon = "settings" })
local player = game.Players.LocalPlayer
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local topGui = Instance.new("ScreenGui")
topGui.Name = "DiabloUI"
topGui.Parent = player.PlayerGui
topGui.ResetOnSpawn = false
topGui.Enabled = true
local statusFrame = Instance.new("Frame")
statusFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
statusFrame.BackgroundTransparency = 0.5
statusFrame.BorderSizePixel = 0
statusFrame.Position = UDim2.new(0.5, -150, 0, 5)
statusFrame.Size = UDim2.new(0, 300, 0, 60)
statusFrame.Parent = topGui
local UICornerFrame = Instance.new("UICorner")
UICornerFrame.CornerRadius = UDim.new(0.1, 0)
UICornerFrame.Parent = statusFrame
local statusLabel = Instance.new("TextLabel")
statusLabel.BackgroundTransparency = 1
statusLabel.Position = UDim2.new(0, 0, 0, 0)
statusLabel.Size = UDim2.new(1, -30, 0.5, 0)
statusLabel.Font = Enum.Font.SourceSansBold
statusLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
statusLabel.TextSize = 18
statusLabel.TextXAlignment = Enum.TextXAlignment.Center
statusLabel.Parent = statusFrame
local creditLabel = Instance.new("TextLabel")
creditLabel.BackgroundTransparency = 1
creditLabel.Position = UDim2.new(0, 0, 0.5, 0)
creditLabel.Size = UDim2.new(1, -30, 0.5, 0)
creditLabel.Font = Enum.Font.SourceSansBold
creditLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
creditLabel.TextSize = 14
creditLabel.TextXAlignment = Enum.TextXAlignment.Center
creditLabel.Parent = statusFrame
local hideButton = Instance.new("TextButton")
hideButton.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
hideButton.BackgroundTransparency = 0.5
hideButton.BorderSizePixel = 0
hideButton.Position = UDim2.new(1, -30, 0, 0)
hideButton.Size = UDim2.new(0, 30, 0, 30)
hideButton.Font = Enum.Font.SourceSansBold
hideButton.TextColor3 = Color3.fromRGB(255, 255, 255)
hideButton.TextSize = 18
hideButton.Text = "X"
hideButton.Parent = statusFrame
hideButton.MouseButton1Click:Connect(function()
    topGui.Enabled = false
end)
local UICornerButton = Instance.new("UICorner")
UICornerButton.CornerRadius = UDim.new(0.1, 0)
UICornerButton.Parent = hideButton
local fps = 0
local timeAccum = 0
local frameCount = 0
RunService.RenderStepped:Connect(function(delta)
    frameCount = frameCount + 1
    timeAccum = timeAccum + delta
    if timeAccum >= 1 then
        fps = math.floor(frameCount / timeAccum)
        frameCount = 0
        timeAccum = 0
    end
end)
local dotsCount = 0
spawn(function()
    while true do
        if topGui.Enabled then
            statusLabel.Text = "| " .. player.Name .. " | FPS: " .. fps
            dotsCount = (dotsCount % 3) + 1
            creditLabel.Text = "This script is made by Diablo" .. ("."):rep(dotsCount)
        end
        wait(0.5)
    end
end)
local function notify(title, message)
    title = title or "YBA Script"
    WindUI:Notify({
        Title = title,
        Content = message
    })
end
local items = {}
local maxLimits = {
    ["Mysterious Arrow"] = 25,
    ["Rokakaka"] = 25,
    ["Gold Coin"] = 45,
    ["Diamond"] = 25,
    ["Pure Rokakaka"] = 10,
    ["Quinton's Glove"] = 10,
    ["Steel Ball"] = 10,
    ["Rib Cage of The Saint's Corpse"] = 10,
    ["Zepellin's Headband"] = 10,
    ["Zeppeli's Hat"] = 10,
    ["Caesar's Headband"] = 10,
    ["Clackers"] = 10,
    ["Stone Mask"] = 10,
    ["Ancient Scroll"] = 10,
    ["Dio's Diary"] = 10,
    ["Pure Rokakaka"] = 999,
    ["Lucky Stone Mask"] = 999,
    ["Lucky Arrow"] = 999,
    ["Gold Umbrella"] = 999,
    ["Left Arm of The Saint's Corpse"] = 999,
    ["Heart of The Saint's Corpse"] = 999,
    ["Pelvis of The Saint's Corpse"] = 999
}
local nonSellable = {"Blue Candy", "Red Candy", "Green Candy", "Yellow Candy", "Lucky Arrow", "Lucky Stone Mask"}
local seen = {}
local itemOptions = {}
for item in pairs(maxLimits) do
    if not seen[item] then
        table.insert(itemOptions, item)
        seen[item] = true
    end
end
for _, candy in ipairs(nonSellable) do
    if not seen[candy] then
        table.insert(itemOptions, candy)
        seen[candy] = true
    end
end
table.sort(itemOptions)
local worthlessItems = {"Gold Coin", "Diamond", "Quinton's Glove", "Zeppeli's Hat", "Caesar's Headband", "Ancient Scroll"}
local function updateItems()
    items = {}
    for itemName in pairs(maxLimits) do
        items[itemName] = 0
    end
    local function countInContainer(container)
        if not container then return end
        for _, item in pairs(container:GetChildren()) do
            if item and item.Name and maxLimits[item.Name] then
                items[item.Name] = (items[item.Name] or 0) + 1
            end
        end
    end
    countInContainer(player.Backpack)
    if player.Character then
        countInContainer(player.Character)
    end
end
local function findSellRemote()
    local plr = game.Players.LocalPlayer
    -- Check character first
    if plr and plr.Character then
        for _, obj in pairs(plr.Character:GetChildren()) do
            if obj:IsA("RemoteEvent") then
                return obj
            end
        end
    end
    local places = {game.Workspace, game.ReplicatedStorage, game:GetService("ReplicatedStorage"), game:GetService("Players")}
    for _, place in pairs(places) do
        if place then
            for _, obj in pairs(place:GetDescendants()) do
                if obj:IsA("RemoteEvent") and (obj.Name:lower():find("remote") or obj.Name:lower():find("remoteevent") or obj.Name:lower():find("sell") or obj.Name:lower():find("server") or obj.Name:lower():find("_ev")) then
                    return obj
                end
            end
        end
    end
    for _, obj in pairs(game.Workspace:GetChildren()) do
        if obj:IsA("RemoteEvent") then
            return obj
        end
    end
    return nil
end
local function sellItem(item)
    if not item then return false end
    local itemName = typeof(item) == "Instance" and item.Name or item
    if table.find(nonSellable, itemName) then
        notify("YBA Script", "Cannot sell " .. itemName .. " as it is not sellable.")
        return false
    end
    local plr = game.Players.LocalPlayer
    if not plr then return false end
    local instanceToSell
    if typeof(item) == "Instance" then
        instanceToSell = item
    elseif typeof(item) == "string" then
        instanceToSell = plr.Backpack:FindFirstChild(item) or (plr.Character and plr.Character:FindFirstChild(item))
    else
        return false
    end
    if not instanceToSell or not instanceToSell.Parent then
        return false
    end
    local plrName = plr.Name
    local living = game.Workspace:FindFirstChild("Living") or game.Workspace
    local target = nil
    if living then
        target = living:FindFirstChild(plrName) or living
    else
        target = game.Workspace
    end
    pcall(function()
        instanceToSell.Parent = target
    end)
    local args = {
        [1] = "EndDialogue",
        [2] = {
            ["NPC"] = "Merchant",
            ["Option"] = "Option2",
            ["Dialogue"] = "Dialogue5"
        }
    }
    local fired = false
    local ok, remote = pcall(findSellRemote)
    if ok and remote then
        pcall(function()
            remote:FireServer(unpack(args))
        end)
        fired = true
    else
        if plr.Character then
            local r = plr.Character:FindFirstChildWhichIsA("RemoteEvent")
            if r then
                pcall(function()
                    r:FireServer(unpack(args))
                end)
                fired = true
            end
        end
    end
    pcall(function()
        if not fired and plr.Character and plr.Character:FindFirstChild("RemoteEvent") then
            plr.Character.RemoteEvent:FireServer(unpack(args))
            fired = true
        end
    end)
    wait(0.12)
    return true
end
local function sellAll(itemName)
    updateItems()
    local count = items[itemName] or 0
    if count == 0 then
        notify("YBA Script", "No " .. itemName .. " found.")
        return
    end
    local sold = 0
    while true do
        local item = player.Backpack:FindFirstChild(itemName) or (player.Character and player.Character:FindFirstChild(itemName))
        if not item then break end
        if sellItem(item) then
            sold = sold + 1
        else
            break
        end
    end
    notify("YBA Script", "Sold " .. sold .. " " .. itemName .. (sold > 1 and "s" or "") .. ".")
end
local function sellAllSelected(selectedItems)
    updateItems()
    local total = 0
    for _, itemName in ipairs(selectedItems) do
        total = total + (items[itemName] or 0)
    end
    if total == 0 then
        notify("YBA Script", "No selected items found.")
        return
    end
    local sold = 0
    for _, itemName in ipairs(selectedItems) do
        while true do
            local item = player.Backpack:FindFirstChild(itemName) or (player.Character and player.Character:FindFirstChild(itemName))
            if not item then break end
            if sellItem(item) then
                sold = sold + 1
            else
                break
            end
        end
    end
    notify("YBA Script", "Sold " .. sold .. " selected item" .. (sold > 1 and "s" or "") .. ".")
end
local function sellAllWorthless()
    updateItems()
    local total = 0
    for _, itemName in ipairs(worthlessItems) do
        total = total + (items[itemName] or 0)
    end
    if total == 0 then
        notify("YBA Script", "No worthless items found.")
        return
    end
    local sold = 0
    for _, itemName in ipairs(worthlessItems) do
        while true do
            local item = player.Backpack:FindFirstChild(itemName) or (player.Character and player.Character:FindFirstChild(itemName))
            if not item then break end
            if sellItem(item) then
                sold = sold + 1
            else
                break
            end
        end
    end
    notify("YBA Script", "Sold " .. sold .. " worthless item" .. (sold > 1 and "s" or "") .. ".")
end
local function sellInventory()
    updateItems()
    local sold = 0
    for itemName, count in pairs(items) do
        if count > 0 and not table.find(nonSellable, itemName) then
            while true do
                local item = player.Backpack:FindFirstChild(itemName) or (player.Character and player.Character:FindFirstChild(itemName))
                if not item then break end
                if sellItem(item) then
                    sold = sold + 1
                else
                    break
                end
            end
        end
    end
    notify("YBA Script", "Sold " .. sold .. " item" .. (sold > 1 and "s" or "") .. " from inventory.")
end
local autoSellMax = false
local function checkAndSellMax()
    local soldSummary = {}
    local tempCounts = {}
    for name in pairs(maxLimits) do
        tempCounts[name] = 0
    end
    local containers = {player.Backpack}
    if player.Character then
        table.insert(containers, player.Character)
    end
    for _, container in ipairs(containers) do
        local children = container:GetChildren()
        for _, item in ipairs(children) do
            local name = item.Name
            if maxLimits[name] then
                tempCounts[name] = tempCounts[name] + 1
                if (tempCounts[name] >= (maxLimits[name] or 25)) and autoSellMax then
                    if sellItem(item) then
                        soldSummary[name] = (soldSummary[name] or 0) + 1
                    end
                end
            end
        end
    end
    local totalSold = 0
    local parts = {}
    for name, n in pairs(soldSummary) do
        totalSold = totalSold + n
        table.insert(parts, n .. "x " .. name)
    end
    if totalSold > 0 then
        local msg = "Auto sold: " .. table.concat(parts, ", ")
        notify("YBA Script", msg)
    end
end
local autoSellSelected = false
local selectedAutoSellItems = {}
local selectedSellAllItems = {}
local lastAutoSellNotify = {}
player.Backpack.ChildAdded:Connect(function(item)
    if autoSellMax then
        checkAndSellMax()
    end
    if autoSellSelected and table.find(selectedAutoSellItems, item.Name) then
        wait(0.2)
        local now = tick()
        local last = lastAutoSellNotify[item.Name] or 0
        if now - last >= 0.5 then
            if sellItem(item) then
                notify("YBA Script", "Auto sold " .. item.Name .. " on pickup.")
                lastAutoSellNotify[item.Name] = now
            end
        end
    end
end)
player.CharacterAdded:Connect(function(char)
    char.ChildAdded:Connect(function(item)
        if autoSellMax then
            checkAndSellMax()
        end
        if autoSellSelected and table.find(selectedAutoSellItems, item.Name) then
            wait(0.2)
            local now = tick()
            local last = lastAutoSellNotify[item.Name] or 0
            if now - last >= 0.5 then
                if sellItem(item) then
                    notify("YBA Script", "Auto sold " .. item.Name .. " on pickup.")
                    lastAutoSellNotify[item.Name] = now
                end
            end
        end
    end)
end)
local noclipEnabled = false
local originalCollides = {}
local noclipConn = nil
local function enforceNoclipForCharacter(char)
    if not char then return end
    for _, part in ipairs(char:GetDescendants()) do
        if part:IsA("BasePart") then
            originalCollides[part] = part.CanCollide
            part.CanCollide = false
        end
    end
end
local function enableNoclip()
    if noclipEnabled then return end
    local char = player.Character
    if not char or not char.Parent then
        noclipEnabled = true
        return
    end
    originalCollides = {}
    enforceNoclipForCharacter(char)
    if noclipConn then noclipConn:Disconnect() noclipConn = nil end
    noclipConn = RunService.Stepped:Connect(function()
        local c = player.Character
        if not c then return end
        for _, p in ipairs(c:GetDescendants()) do
            if p:IsA("BasePart") then
                if p.CanCollide then p.CanCollide = false end
            end
        end
    end)
    noclipEnabled = true
end
local function disableNoclip()
    if not noclipEnabled then return end
    if noclipConn then noclipConn:Disconnect() noclipConn = nil end
    for part, val in pairs(originalCollides) do
        if part and part.Parent and part:IsA("BasePart") then
            pcall(function() part.CanCollide = val end)
        end
    end
    originalCollides = {}
    noclipEnabled = false
end
local speedValue = 100
local function travelToStud(target)
    if not player.Character or not player.Character.HumanoidRootPart then return end
    local hrp = player.Character.HumanoidRootPart
    local targetPos = typeof(target) == "Vector3" and target or target.Position
    local vector = targetPos - hrp.Position
    local length = vector.Magnitude
    local step_size = (afkFarmOn and 5 or 50) * speedValue
    local num_tp = math.ceil(length / step_size)
    if num_tp < 1 then num_tp = 1 end
    for i = 1, num_tp do
        if not player.Character or not player.Character.HumanoidRootPart then return end
        hrp.CFrame = hrp.CFrame + vector / num_tp
        wait(tpDelay)
    end
end
local function travelToTween(target)
    if not player.Character or not player.Character.HumanoidRootPart then return end
    local hrp = player.Character.HumanoidRootPart
    local targetPos = typeof(target) == "Vector3" and target or target.Position
    local tweenInfo = TweenInfo.new(0.5 / speedValue, Enum.EasingStyle.Linear)
    local tween = TweenService:Create(hrp, tweenInfo, {CFrame = CFrame.new(targetPos)})
    tween:Play()
    tween.Completed:Wait()
end
local travelMethod = "Stud"
local function travelTo(target)
    if travelMethod == "Stud" then
        travelToStud(target)
    elseif travelMethod == "Tween" then
        travelToTween(target)
    end
end
local function teleportToRandom()
    local map = game.Workspace:FindFirstChild("Map") or game.Workspace
    local bounds = {
        minX = -590, maxX = 590,
        minZ = -520, maxZ = 530,
        y = 100
    }
    local randomX = math.random(bounds.minX, bounds.maxX)
    local randomZ = math.random(bounds.minZ, bounds.maxZ)
    if not player.Character or not player.Character.HumanoidRootPart then return end
    local hrp = player.Character.HumanoidRootPart
    hrp.CFrame = CFrame.new(randomX, bounds.y, randomZ)
end
local function roamToRandom()
    local map = game.Workspace:FindFirstChild("Map") or game.Workspace
    local bounds = {
        minX = -590, maxX = 590,
        minZ = -520, maxZ = 530,
        y = 100
    }
    local randomX = math.random(bounds.minX, bounds.maxX)
    local randomZ = math.random(bounds.minZ, bounds.maxZ)
    local randomPos = Vector3.new(randomX, bounds.y, randomZ)
    travelTo(randomPos)
end
local normalFarmOn = false
local afkFarmOn = false
local selectedFarmItems = {}
local normalCoroutine = nil
local afkCoroutine = nil
local tpDelay = 0.05
local originalTpDelay = 0.05
local function getClosestItem()
    local hrp = player.Character and player.Character.HumanoidRootPart
    if not hrp then return nil end
    local minDist = math.huge
    local closest = nil
    for _, v in pairs(game.Workspace.Item_Spawns.Items:GetChildren()) do
        local itemPart = v:FindFirstChildOfClass("MeshPart") or v:FindFirstChildOfClass("Part")
        local proxPrompt = v:FindFirstChild("ProximityPrompt")
        if itemPart and proxPrompt and itemPart.Transparency < 1 and (#selectedFarmItems == 0 or table.find(selectedFarmItems, proxPrompt.ObjectText)) then
            local dist = (itemPart.Position - hrp.Position).Magnitude
            if dist < minDist then
                minDist = dist
                closest = v
            end
        end
    end
    return closest
end
local function normalFarm()
    while normalFarmOn do
        if not player.Character or not player.Character:FindFirstChild("Humanoid") or player.Character.Humanoid.Health <= 0 then
            wait(1)
            continue
        end
        local v = getClosestItem()
        if v then
            local itemPart = v:FindFirstChildOfClass("MeshPart") or v:FindFirstChildOfClass("Part")
            local proxPrompt = v:FindFirstChild("ProximityPrompt")
            if instantPickup then
                instantTravelTo(itemPart)
                wait(0.08) -- small delay for position sync
                checkAndSellMax()
                fireproximityprompt(proxPrompt, 0, true)
            else
                travelTo(itemPart)
                local hrp = player.Character.HumanoidRootPart
                if (itemPart.Position - hrp.Position).Magnitude < 5 then
                    checkAndSellMax()
                    fireproximityprompt(proxPrompt, 4)
                    wait(0.1)
                    if v:IsDescendantOf(game.Workspace) then
                        fireproximityprompt(proxPrompt, 4)
                    end
                end
            end
            checkAndSellMax()
        else
            teleportToRandom()
        end
        wait(0.2)
    end
end
local function afkFarm()
    while afkFarmOn do
        if not player.Character or not player.Character:FindFirstChild("Humanoid") or player.Character.Humanoid.Health <= 0 then
            wait(1)
            continue
        end
        local roaming = true
        while roaming and afkFarmOn do
            if not player.Character or not player.Character:FindFirstChild("Humanoid") or player.Character.Humanoid.Health <= 0 then
                break
            end
            local v = getClosestItem()
            if v then
                roaming = false
                local itemPart = v:FindFirstChildOfClass("MeshPart") or v:FindFirstChildOfClass("Part")
                local proxPrompt = v:FindFirstChild("ProximityPrompt")
                if instantPickup then
                    instantTravelTo(itemPart)
                    wait(0.08)
                    checkAndSellMax()
                    fireproximityprompt(proxPrompt, 0, true)
                else
                    travelTo(itemPart)
                    local hrp = player.Character.HumanoidRootPart
                    if (itemPart.Position - hrp.Position).Magnitude < 5 then
                        checkAndSellMax()
                        fireproximityprompt(proxPrompt, 4)
                        wait(0.1) -- Wait briefly
                        if v:IsDescendantOf(game.Workspace) then
                            fireproximityprompt(proxPrompt, 4) -- Try again if not picked
                        end
                    end
                end
                checkAndSellMax()
                roaming = true
            else
                roamToRandom()
            end
            wait(0.05)
        end
    end
end
local function startFarming(method)
    if method == "Normal" then
        normalFarmOn = true
        normalCoroutine = coroutine.wrap(normalFarm)()
    elseif method == "AFK Farming" then
        afkFarmOn = true
        afkCoroutine = coroutine.wrap(afkFarm)()
    end
    enableNoclip()
end
local function stopFarming()
    normalFarmOn = false
    afkFarmOn = false
    disableNoclip()
end
player.CharacterAdded:Connect(function(char)
    if normalFarmOn or afkFarmOn then
        wait(3) -- Changed to 3 seconds
        enableNoclip()
        if normalFarmOn then
            if normalCoroutine then coroutine.close(normalCoroutine) end
            normalCoroutine = coroutine.wrap(normalFarm)()
        elseif afkFarmOn then
            if afkCoroutine then coroutine.close(afkCoroutine) end
            afkCoroutine = coroutine.wrap(afkFarm)()
        end
    end
end)
local itemESP = false
local espConnection
local function addItemESP(v)
    local itemPart = v:FindFirstChildOfClass("MeshPart") or v:FindFirstChildOfClass("Part")
    local prox = v:FindFirstChild("ProximityPrompt")
    if itemPart and prox and itemPart.Transparency < 1 then -- Added check
        local itemName = prox.ObjectText or "Unknown Item"
        if not v:FindFirstChild("ItemESP") then
            local hl = Instance.new("Highlight")
            hl.Name = "ItemESP"
            hl.FillTransparency = 0.7
            hl.FillColor = Color3.fromRGB(0, 255, 0)
            hl.OutlineTransparency = 0
            hl.OutlineColor = Color3.fromRGB(255, 0, 0)
            hl.Adornee = v
            hl.Parent = v
        end
        if not v:FindFirstChild("ItemESPName") then
            local bb = Instance.new("BillboardGui")
            bb.Name = "ItemESPName"
            bb.Adornee = itemPart
            bb.Size = UDim2.new(0, 200, 0, 50)
            bb.StudsOffset = Vector3.new(0, 3, 0)
            bb.AlwaysOnTop = true
            bb.Parent = v
            local tl = Instance.new("TextLabel")
            tl.Size = UDim2.new(1, 0, 1, 0)
            tl.BackgroundTransparency = 1
            tl.Text = itemName
            tl.TextColor3 = Color3.fromRGB(255, 255, 255)
            tl.TextSize = 24
            tl.TextStrokeTransparency = 0.5
            tl.Font = Enum.Font.SourceSansBold
            tl.Parent = bb
        end
    end
end
local function enableItemESP()
    for _, v in pairs(game.Workspace.Item_Spawns.Items:GetChildren()) do
        addItemESP(v)
    end
    espConnection = game.Workspace.Item_Spawns.Items.ChildAdded:Connect(function(v)
        wait(0.1)
        addItemESP(v)
    end)
end
local function disableItemESP()
    for _, v in pairs(game.Workspace.Item_Spawns.Items:GetChildren()) do
        local hl = v:FindFirstChild("ItemESP")
        if hl then
            hl:Destroy()
        end
        local bb = v:FindFirstChild("ItemESPName")
        if bb then
            bb:Destroy()
        end
    end
    if espConnection then
        espConnection:Disconnect()
    end
end
local playerESP = false
local playerESPConnections = {}
local function addPlayerESP(plr)
    if plr == player then return end
    if not plr.Character then return end
    local char = plr.Character
    local hl = Instance.new("Highlight")
    hl.Name = "PlayerESP"
    hl.FillTransparency = 0.7
    hl.FillColor = Color3.fromRGB(255, 0, 0) -- Red fill
    hl.OutlineTransparency = 0
    hl.OutlineColor = Color3.fromRGB(255, 255, 255) -- White outline
    hl.Adornee = char
    hl.Parent = char
    local bb = Instance.new("BillboardGui")
    bb.Name = "PlayerESPName"
    bb.Adornee = char:FindFirstChild("Head")
    bb.Size = UDim2.new(0, 200, 0, 50)
    bb.StudsOffset = Vector3.new(0, 3, 0)
    bb.AlwaysOnTop = true
    bb.Parent = char
    local tl = Instance.new("TextLabel")
    tl.Size = UDim2.new(1, 0, 1, 0)
    tl.BackgroundTransparency = 1
    tl.Text = plr.Name
    tl.TextColor3 = Color3.fromRGB(255, 255, 255)
    tl.TextSize = 24
    tl.TextStrokeTransparency = 0.5
    tl.Font = Enum.Font.SourceSansBold
    tl.Parent = bb
    local conn = plr.CharacterAdded:Connect(function(newChar)
        hl.Adornee = newChar
        bb.Adornee = newChar:WaitForChild("Head")
    end)
    table.insert(playerESPConnections, conn)
end
local function enablePlayerESP()
    for _, plr in pairs(game.Players:GetPlayers()) do
        addPlayerESP(plr)
    end
    local addedConn = game.Players.PlayerAdded:Connect(function(plr)
        addPlayerESP(plr)
    end)
    table.insert(playerESPConnections, addedConn)
end
local function disablePlayerESP()
    for _, plr in pairs(game.Players:GetPlayers()) do
        if plr.Character then
            local hl = plr.Character:FindFirstChild("PlayerESP")
            if hl then
                hl:Destroy()
            end
            local bb = plr.Character:FindFirstChild("PlayerESPName")
            if bb then
                bb:Destroy()
            end
        end
    end
    for _, conn in pairs(playerESPConnections) do
        conn:Disconnect()
    end
    playerESPConnections = {}
end
local itemNotifier = false
local notifierConnection
local function enableItemNotifier()
    notifierConnection = game.Workspace.Item_Spawns.Items.ChildAdded:Connect(function(v)
        wait(0.1)
        local prox = v:FindFirstChild("ProximityPrompt")
        if prox then
            local itemName = prox.ObjectText or "Unknown Item"
            notify("YBA Script", itemName .. " has spawned!")
        end
    end)
end
local function disableItemNotifier()
    if notifierConnection then
        notifierConnection:Disconnect()
    end
end
local instantPickup = false
local instantPickupConnection = nil
local defaultHoldDuration = 0.5
local function getItemContainer()
    local spawns = workspace:FindFirstChild("Item_Spawns")
    if not spawns then return nil end
    return spawns:FindFirstChild("Items")
end
local function setPromptsInstant(instant)
    local container = getItemContainer()
    if not container then return end
    for _, v in pairs(container:GetChildren()) do
        local prox = v:FindFirstChild("ProximityPrompt")
        if prox then
            pcall(function() prox.HoldDuration = instant and 0 or defaultHoldDuration end)
        end
    end
end
local function enableInstantPickup()
    instantPickup = true
    setPromptsInstant(true)
    local container = getItemContainer()
    if container then
        instantPickupConnection = container.ChildAdded:Connect(function(v)
            wait(0.05)
            local prox = v:FindFirstChild("ProximityPrompt")
            local part = v:FindFirstChildOfClass("MeshPart") or v:FindFirstChildOfClass("Part")
            if prox and part.Transparency < 1 then -- Added check
                pcall(function() prox.HoldDuration = 0 end)
                pcall(function() fireproximityprompt(prox, 0) end)
            end
        end)
    end
end
local function disableInstantPickup()
    instantPickup = false
    setPromptsInstant(false)
    if instantPickupConnection then
        instantPickupConnection:Disconnect()
        instantPickupConnection = nil
    end
end
local function instantTravelTo(target)
    if not player.Character or not player.Character.HumanoidRootPart then return end
    local hrp = player.Character.HumanoidRootPart
    local targetPos = typeof(target) == "Vector3" and target or target.Position
    hrp.CFrame = CFrame.new(targetPos + Vector3.new(0, 0.10, 0)) -- slight offset to avoid stuck
end
local afkCameraOn = false
local originalCameraType = nil
local cameraConnection = nil
local cancelGui = nil
local function enableAFKCamera()
    if not (normalFarmOn or afkFarmOn) then
        notify("YBA Script", "AFK Camera only works when farming is enabled.")
        afkCameraToggle:Set(false)
        return
    end
    originalCameraType = workspace.CurrentCamera.CameraType
    workspace.CurrentCamera.CameraType = Enum.CameraType.Scriptable
    cameraConnection = RunService.RenderStepped:Connect(function()
        if player.Character and player.Character:FindFirstChild("Head") then
            local head = player.Character.Head
            local camPos = head.Position + Vector3.new(0, 15, 0) -- Adjust height as needed, 15 studs above
            local lookAt = head.Position
            workspace.CurrentCamera.CFrame = CFrame.new(camPos, lookAt)
        end
    end)
    cancelGui = Instance.new("ScreenGui")
    cancelGui.Name = "CancelAFK"
    cancelGui.Parent = player.PlayerGui
    cancelGui.ResetOnSpawn = false
    local cancelButton = Instance.new("TextButton")
    cancelButton.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
    cancelButton.BorderSizePixel = 0
    cancelButton.Position = UDim2.new(0.5, -100, 0.9, -50)
    cancelButton.Size = UDim2.new(0, 200, 0, 50)
    cancelButton.Font = Enum.Font.SourceSansBold
    cancelButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    cancelButton.TextSize = 24
    cancelButton.Text = "Cancel AFK Camera"
    cancelButton.Parent = cancelGui
    cancelButton.MouseButton1Click:Connect(function()
        afkCameraToggle:Set(false)
    end)
    local uicorner = Instance.new("UICorner")
    uicorner.Parent = cancelButton
end
local function disableAFKCamera()
    if originalCameraType then
        workspace.CurrentCamera.CameraType = originalCameraType
    end
    if cameraConnection then
        cameraConnection:Disconnect()
    end
    if cancelGui then
        cancelGui:Destroy()
    end
end
player.CharacterAdded:Connect(function(char)
    if afkCameraOn then
        wait(1)
    end
end)
local farmMethod = "Normal"
FarmingTab:Dropdown({
    Flag = "FarmMethod",
    Title = "Farm Method",
    Values = {"Normal", "AFK Farming"},
    Value = "Normal",
    Callback = function(option)
        farmMethod = option
    end
})
FarmingTab:Space()
FarmingTab:Dropdown({
    Flag = "FarmItem",
    Title = "Select Item to Farm",
    Values = itemOptions,
    Multi = true,
    Callback = function(selected)
        selectedFarmItems = selected
    end
})
FarmingTab:Space()
FarmingTab:Dropdown({
    Flag = "TravelMethod",
    Title = "Travel Method",
    Values = {"Stud", "Tween"},
    Value = "Stud",
    Callback = function(option)
        travelMethod = option
    end
})
FarmingTab:Space()
local tpToItemsToggle = FarmingTab:Toggle({
    Flag = "TpToItems",
    Title = "Enable Farming",
    Default = false,
    Callback = function(value)
        local method = farmMethod
        if value then
            notify("YBA Script", method .. " enabled.")
            startFarming(method)
        else
            notify("YBA Script", "Farming disabled.")
            stopFarming()
        end
    end
})
FarmingTab:Space()
FarmingTab:Section({
    Title = "Gamble",
})
local gambleOn = false
local lastGambleTime = 0
local gambleToggle = FarmingTab:Toggle({
    Flag = "Gamble",
    Title = "Enable",
    Default = false,
    Callback = function(value)
        gambleOn = value
        if value then
            notify("YBA Script", "Auto Gamble enabled.")
        else
            notify("YBA Script", "Auto Gamble disabled.")
        end
    end
})
spawn(function()
    while true do
        wait(0.5)
        if gambleOn then
            pcall(function()
                local hasGold = false
                local goldItem = player.Backpack:FindFirstChild("Gold Coin") or (player.Character and player.Character:FindFirstChild("Gold Coin"))
                if goldItem then
                    hasGold = true
                    if goldItem.Parent == player.Backpack then
                        goldItem.Parent = player.Character
                    end
                end
                local money = player.PlayerStats.Money.Value
                if hasGold and money >= 750 then
                    local remote = player.Character:FindFirstChild("RemoteEvent")
                    if remote then
                        remote:FireServer("DialogueInteracted", {
                            ["DialogueName"] = "Item Machine",
                            ["Speaker"] = "Item Machine"
                        })
                        remote:FireServer("EndDialogue", {
                            ["NPC"] = "Item Machine",
                            ["Option"] = "Option1",
                            ["Dialogue"] = "Dialogue1"
                        })
                        lastGambleTime = tick()
                    end
                    wait(0.5)
                end
            end)
        end
    end
end)
player.Backpack.ChildAdded:Connect(function(item)
    if tick() - lastGambleTime < 2 then
        notify("YBA Script", "Gambled and got: " .. item.Name)
    end
end)
local autoSellMaxToggle = SellingTab:Toggle({
    Flag = "AutoSellMax",
    Title = "Auto Sell on Max",
    Default = false,
    Callback = function(value)
        autoSellMax = value
        if autoSellMax then
            notify("YBA Script", "Auto Sell on Max enabled.")
            checkAndSellMax()
        else
            notify("YBA Script", "Auto Sell on Max disabled.")
        end
    end
})
SellingTab:Space()
SellingTab:Dropdown({
    Flag = "AutoSellItems",
    Title = "Auto Sell Items (on Pickup)",
    Values = itemOptions,
    Multi = true,
    Callback = function(selected)
        selectedAutoSellItems = selected
    end
})
SellingTab:Space()
local autoSellSelectedToggle = SellingTab:Toggle({
    Flag = "AutoSellSelected",
    Title = "Auto Sell Selected on Pickup",
    Default = false,
    Callback = function(value)
        autoSellSelected = value
        if autoSellSelected then
            notify("YBA Script", "Auto Sell Selected enabled.")
        else
            notify("YBA Script", "Auto Sell Selected disabled.")
        end
    end
})
SellingTab:Space()
SellingTab:Dropdown({
    Flag = "SellAllItems",
    Title = "Select Items to Sell All Now",
    Values = itemOptions,
    Multi = true,
    Callback = function(selected)
        selectedSellAllItems = selected
    end
})
SellingTab:Space()
SellingTab:Button({
    Title = "Sell All Selected Now",
    Callback = function()
        sellAllSelected(selectedSellAllItems)
    end
})
SellingTab:Space()
SellingTab:Button({
    Title = "Sell All Worthless Items",
    Callback = function()
        sellAllWorthless()
    end
})
SellingTab:Space()
SellingTab:Button({
    Title = "Sell Inventory",
    Callback = function()
        sellInventory()
    end
})
local itemESPToggle = VisualTab:Toggle({
    Flag = "ItemESP",
    Title = "Item ESP",
    Default = false,
    Callback = function(value)
        itemESP = value
        if itemESP then
            notify("YBA Script", "Item ESP enabled.")
            enableItemESP()
        else
            notify("YBA Script", "Item ESP disabled.")
            disableItemESP()
        end
    end
})
VisualTab:Space()
local playerESPToggle = VisualTab:Toggle({
    Flag = "PlayerESP",
    Title = "Player ESP",
    Default = false,
    Callback = function(value)
        playerESP = value
        if playerESP then
            notify("YBA Script", "Player ESP enabled.")
            enablePlayerESP()
        else
            notify("YBA Script", "Player ESP disabled.")
            disablePlayerESP()
        end
    end
})
VisualTab:Space()
local itemNotifierToggle = VisualTab:Toggle({
    Flag = "ItemNotifier",
    Title = "Item Spawn Notifier",
    Default = false,
    Callback = function(value)
        itemNotifier = value
        if itemNotifier then
            notify("YBA Script", "Item Spawn Notifier enabled.")
            enableItemNotifier()
        else
            notify("YBA Script", "Item Spawn Notifier disabled.")
            disableItemNotifier()
        end
    end
})
VisualTab:Space()
local showTopBarToggle = VisualTab:Toggle({
    Flag = "ShowTopBar",
    Title = "Show Top Bar",
    Default = true,
    Callback = function(value)
        topGui.Enabled = value
    end
})
local antiAFKToggle = MiscTab:Toggle({
    Flag = "AntiAFK",
    Title = "Anti-AFK",
    Default = false,
    Callback = function(value)
        if value then
            notify("YBA Script", "Anti-AFK enabled.")
            spawn(function()
                while value do
                    wait(300)
                    local vu = game:GetService("VirtualUser")
                    vu:CaptureController()
                    vu:ClickButton2(Vector2.new())
                end
            end)
        else
            notify("YBA Script", "Anti-AFK disabled.")
        end
    end
})
MiscTab:Space()
local originalLighting = {
    Brightness = game.Lighting.Brightness,
    ClockTime = game.Lighting.ClockTime,
    FogEnd = game.Lighting.FogEnd,
    GlobalShadows = game.Lighting.GlobalShadows,
    Ambient = game.Lighting.Ambient
}
local fpsBoosterToggle = MiscTab:Toggle({
    Flag = "FpsBooster",
    Title = "FPS Booster",
    Default = false,
    Callback = function(value)
        if value then
            notify("YBA Script", "FPS Booster enabled.")
            local lighting = game.Lighting
            lighting.Brightness = 2
            lighting.ClockTime = 14
            lighting.FogEnd = 100000
            lighting.GlobalShadows = false
            lighting.Ambient = Color3.fromRGB(255, 255, 255)
            for _, obj in pairs(game.Workspace:GetDescendants()) do
                if obj:IsA("Highlight") then
                    obj.Enabled = false
                end
            end
            if game.Lighting:FindFirstChild("Bloom") then
                game.Lighting.Bloom.Enabled = false
            end
            if game.Lighting:FindFirstChild("SunRays") then
                game.Lighting.SunRays.Enabled = false
            end
            if game.Lighting:FindFirstChild("DepthOfField") then
                game.Lighting.DepthOfField.Enabled = false
            end
        else
            notify("YBA Script", "FPS Booster disabled.")
            local lighting = game.Lighting
            lighting.Brightness = originalLighting.Brightness
            lighting.ClockTime = originalLighting.ClockTime
            lighting.FogEnd = originalLighting.FogEnd
            lighting.GlobalShadows = originalLighting.GlobalShadows
            lighting.Ambient = originalLighting.Ambient
            for _, obj in pairs(game.Workspace:GetDescendants()) do
                if obj:IsA("Highlight") then
                    obj.Enabled = true
                end
            end
            if game.Lighting:FindFirstChild("Bloom") then
                game.Lighting.Bloom.Enabled = true
            end
            if game.Lighting:FindFirstChild("SunRays") then
                game.Lighting.SunRays.Enabled = true
            end
            if game.Lighting:FindFirstChild("DepthOfField") then
                game.Lighting.DepthOfField.Enabled = true
            end
        end
    end
})
MiscTab:Space()
local instantPickupToggle = MiscTab:Toggle({
    Flag = "InstantPickup",
    Title = "Instant Pick Up",
    Default = false,
    Callback = function(value)
        if value then
            enableInstantPickup()
            notify("YBA Script", "Instant Pick Up enabled.")
        else
            disableInstantPickup()
            notify("YBA Script", "Instant Pick Up disabled.")
        end
    end
})
MiscTab:Space()
local afkCameraToggle = MiscTab:Toggle({
    Flag = "AFKCamera",
    Title = "AFK Camera",
    Default = false,
    Callback = function(value)
        afkCameraOn = value
        if value then
            notify("YBA Script", "AFK Camera enabled.")
            enableAFKCamera()
        else
            notify("YBA Script", "AFK Camera disabled.")
            disableAFKCamera()
        end
    end
})
MiscTab:Space()
local selectedSoundItems = {}
MiscTab:Dropdown({
    Flag = "SoundItem",
    Title = "Select Item for Sound",
    Values = itemOptions,
    Multi = true,
    Callback = function(selected)
        selectedSoundItems = selected
    end
})
MiscTab:Space()
local soundNotifier = false
local soundNotifierConnection
local function enableSoundNotifier()
    soundNotifierConnection = game.Workspace.Item_Spawns.Items.ChildAdded:Connect(function(v)
        wait(0.1)
        local prox = v:FindFirstChild("ProximityPrompt")
        if prox and table.find(selectedSoundItems, prox.ObjectText) then
            local sound = Instance.new("Sound")
            sound.SoundId = "rbxassetid://4590657391" -- ting sound
            sound.Volume = 1
            sound.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")
            sound:Play()
            sound.Ended:Connect(function()
                sound:Destroy()
            end)
        end
    end)
end
local function disableSoundNotifier()
    if soundNotifierConnection then
        soundNotifierConnection:Disconnect()
    end
end
local soundNotifierToggle = MiscTab:Toggle({
    Flag = "SoundNotifier",
    Title = "Sound Notifier",
    Default = false,
    Callback = function(value)
        soundNotifier = value
        if value then
            notify("YBA Script", "Sound Notifier enabled for selected items")
            enableSoundNotifier()
        else
            notify("YBA Script", "Sound Notifier disabled.")
            disableSoundNotifier()
        end
    end
})
MiscTab:Space()
local lastSpeedNotify = 0
local farmingSpeedSlider = AdjustTab:Slider({
    Flag = "FarmingSpeed",
    Title = "Farming Speed (Max: 100)",
    Step = 1,
    Value = {
        Min = 1,
        Max = 100,
        Default = 100,
    },
    Callback = function(value)
        speedValue = value
        tpDelay = originalTpDelay / value
        if os.clock() - lastSpeedNotify > 1 then
            notify("YBA Script", "Farming Speed adjusted to " .. value .. ".")
            lastSpeedNotify = os.clock()
        end
    end
})
AdjustTab:Space()
AdjustTab:Button({
    Title = "Reset",
    Callback = function()
        tpDelay = originalTpDelay
        farmingSpeedSlider:Set(1)
        notify("YBA Script", "Farming Speed reset to default.")
    end
})
local quests = {
    ["Level 1"] = {
        npc = "Officer Sam",
        dialogue = {["NPC"] = "Officer Sam", ["Option"] = "Option1", ["Dialogue"] = "Dialogue1"},
        enemy = "Thug",
        amount = 5
    },
    ["Level 10"] = {
        npc = "Deputy Bertrude",
        dialogue = {["NPC"] = "Deputy Bertrude", ["Option"] = "Option1", ["Dialogue"] = "Dialogue1"},
        enemy = "Corrupt Police",
        amount = 5
    },
    ["Level 15"] = {
        npc = "Abbacchio's Partner",
        dialogue = {["NPC"] = "Abbacchio's Partner", ["Option"] = "Option1", ["Dialogue"] = "Dialogue1"},
        enemy = "Alpha Thug",
        amount = 5
    },
    ["Level 25"] = {
        npc = "Antonio Zeppeli",
        dialogue = {["NPC"] = "Antonio Zeppeli", ["Option"] = "Option1", ["Dialogue"] = "Dialogue1"},
        enemy = "Zombie",
        amount = 10
    },
    ["Level 30"] = {
        npc = "Doppio",
        dialogue = {["NPC"] = "Doppio", ["Option"] = "Option1", ["Dialogue"] = "Dialogue1"},
        enemy = "Vampire",
        amount = 10
    },
    ["Level 35"] = {
        npc = "Dio",
        dialogue = {["NPC"] = "Dio", ["Option"] = "Option1", ["Dialogue"] = "Dialogue1"},
        enemy = "Vampire Minion",
        amount = 10
    },
}
local selectedLevel = "Level 1"
local distance = 3
local levelFarmOn = false
local levelCoroutine = nil
local function findModelByName(name)
    local npcsFolder = game.Workspace:FindFirstChild("NPCs")
    if npcsFolder then
        local npc = npcsFolder:FindFirstChild(name)
        if npc and npc:IsA("Model") then
            return npc
        end
    end
    for _, v in pairs(game.Workspace:GetDescendants()) do
        if v:IsA("Model") and v.Name == name then
            return v
        end
    end
    return nil
end
local function findNearestEnemy(enemyType)
    if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then return nil end
    local hrp = player.Character.HumanoidRootPart
    local minDist = math.huge
    local target = nil
    for _, mob in pairs(game.Workspace:GetDescendants()) do
        if mob:IsA("Model") and mob.Name == enemyType and mob:FindFirstChild("Humanoid") and mob.Humanoid.Health > 0 and mob:FindFirstChild("HumanoidRootPart") then
            local dist = (mob.HumanoidRootPart.Position - hrp.Position).Magnitude
            if dist < minDist then
                minDist = dist
                target = mob
            end
        end
    end
    return target
end
local function levelFarm()
    enableNoclip()
    while levelFarmOn do
        if not player.Character or not player.Character:FindFirstChild("Humanoid") or player.Character.Humanoid.Health <= 0 then
            wait(1)
            continue
        end
        local quest = quests[selectedLevel]
        local npc = quest.npc
        local npcModel = findModelByName(npc)
        if not npcModel or not npcModel:FindFirstChild("HumanoidRootPart") then
            notify("YBA Script", "NPC not found: " .. npc)
            levelFarmOn = false
            break
        end
        local npcHRP = npcModel.HumanoidRootPart
        travelTo(npcHRP.Position)
        wait(0.5)
        local remote = player.Character:FindFirstChild("RemoteEvent")
        if not remote then
            notify("YBA Script", "Remote not found")
            levelFarmOn = false
            break
        end
        remote:FireServer("DialogueInteracted", {["DialogueName"] = npc, ["Speaker"] = npc})
        wait(0.1)
        remote:FireServer("EndDialogue", quest.dialogue)
        wait(0.5)
        for i = 1, quest.amount do
            local enemy = nil
            while not enemy and levelFarmOn do
                enemy = findNearestEnemy(quest.enemy)
                wait(1)
            end
            if not levelFarmOn then break end
            local enemyHRP = enemy.HumanoidRootPart
            travelTo(enemyHRP.Position - enemyHRP.CFrame.LookVector * distance)
            wait(0.5)
            local connection
            connection = RunService.Heartbeat:Connect(function()
                if not enemy or not enemy:FindFirstChild("Humanoid") or enemy.Humanoid.Health <= 0 or not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
                    if connection then connection:Disconnect() end
                    return
                end
                local pos = enemyHRP.Position - enemyHRP.CFrame.LookVector * distance
                player.Character.HumanoidRootPart.CFrame = CFrame.lookAt(pos, enemyHRP.Position)
            end)
            local punchTime = 0
            while enemy and enemy:FindFirstChild("Humanoid") and enemy.Humanoid.Health > 0 and levelFarmOn do
                if tick() - punchTime > 0.08 then
                    remote:FireServer("Punch")
                    punchTime = tick()
                end
                wait(0.01)
            end
            if connection then connection:Disconnect() end
        end
        if not levelFarmOn then break end
        travelTo(npcHRP.Position)
        wait(0.5)
        remote:FireServer("DialogueInteracted", {["DialogueName"] = npc, ["Speaker"] = npc})
        wait(0.1)
        remote:FireServer("EndDialogue", quest.dialogue)
        wait(0.5)
    end
    disableNoclip()
end
LevelFarmTab:Dropdown({
    Flag = "SelectLevel",
    Title = "Select Level",
    Values = {"Level 1", "Level 10", "Level 15", "Level 25", "Level 30", "Level 35"},
    Value = "Level 1",
    Callback = function(option)
        selectedLevel = option
    end
})
LevelFarmTab:Space()
LevelFarmTab:Slider({
    Flag = "EnemyDistance",
    Title = "Distance from Enemy",
    Step = 0.5,
    Value = {
        Min = 1,
        Max = 10,
        Default = 3,
    },
    Callback = function(value)
        distance = value
    end
})
LevelFarmTab:Space()
local levelFarmToggle = LevelFarmTab:Toggle({
    Flag = "LevelFarm",
    Title = "Enable Level Farm",
    Default = false,
    Callback = function(value)
        if value then
            notify("YBA Script", "This feature is not yet available.")
            levelFarmToggle:Set(false)
        end
    end
})
LevelFarmTab:Section({
    Title = "This feature is not yet available.",
    TextSize = 18,
    TextTransparency = .35,
    FontWeight = Enum.FontWeight.Medium,
})
player.CharacterAdded:Connect(function(char)
    if levelFarmOn then
        wait(2)
        enableNoclip()
        levelCoroutine = coroutine.wrap(levelFarm)()
    end
end)
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local StarterGui = game:GetService("StarterGui")
local workspace = game:GetService("Workspace")
local player = Players.LocalPlayer
local camera = workspace.CurrentCamera
-- CONFIG
local BACK_DISTANCE = 2
local BACK_HEIGHT = 0.5
local PLAYER_HEIGHT = 20
local ALIGN_RESPONSIVENESS = 250
local ALIGN_MAX_FORCE = 1e7
local CHECK_SCAN_INTERVAL = 1.0
local SMOOTH_FALLBACK_ALPHA = 0.85
local scanTimer = 0
local modelCache = {}
local function isCharacterModel(m)
    if not m or not m:IsA("Model") then return false end
    return m:FindFirstChild("Humanoid") and m:FindFirstChild("HumanoidRootPart")
end
local function rebuildModelCache()
    modelCache = {}
    for _, child in ipairs(workspace:GetChildren()) do
        if isCharacterModel(child) then
            table.insert(modelCache, child)
        else
            for _, c2 in ipairs(child:GetChildren()) do
                if isCharacterModel(c2) then table.insert(modelCache, c2) end
            end
        end
    end
    for _, pl in ipairs(Players:GetPlayers()) do
        if pl ~= player and pl.Character and isCharacterModel(pl.Character) then
            table.insert(modelCache, pl.Character)
        end
    end
end
rebuildModelCache()
workspace.ChildAdded:Connect(function(c)
    if isCharacterModel(c) then table.insert(modelCache, c) else
        for _, c2 in ipairs(c:GetChildren()) do if isCharacterModel(c2) then table.insert(modelCache, c2) end end
    end
end)
workspace.ChildRemoved:Connect(function(c)
    for i = #modelCache, 1, -1 do if modelCache[i] == c then table.remove(modelCache, i) end end
end)
Players.PlayerAdded:Connect(function(pl)
    pl.CharacterAdded:Connect(function(ch)
        if isCharacterModel(ch) then table.insert(modelCache, ch) end
    end)
end)
Players.PlayerRemoving:Connect(function(pl)
    if pl.Character then
        for i = #modelCache, 1, -1 do if modelCache[i] == pl.Character then table.remove(modelCache, i) end end
    end
end)
local function findClosestByName(name)
    if not name or name == "" then return nil end
    local root = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
    if not root then return nil end
    local rootPos = root.Position
    local lower = name:lower()
    local closest, minD = nil, math.huge
    for _, pl in ipairs(Players:GetPlayers()) do
        if pl ~= player and pl.Character and pl.Character:FindFirstChild("HumanoidRootPart") then
            local match = false
            if pl.Name:lower():find(lower) then match = true end
            if pl.DisplayName and pl.DisplayName:lower():find(lower) then match = true end
            if match then
                local hrp = pl.Character:FindFirstChild("HumanoidRootPart")
                local hum = pl.Character:FindFirstChild("Humanoid")
                if hrp and hum and hum.Health > 0 then
                    local d = (hrp.Position - rootPos).Magnitude
                    if d < minD then minD, closest = d, pl.Character end
                end
            end
        end
    end
    for _, model in ipairs(modelCache) do
        if model and model.Parent and model ~= player.Character then
            if model.Name:lower():find(lower) then
                local hrp = model:FindFirstChild("HumanoidRootPart")
                local hum = model:FindFirstChild("Humanoid")
                if hrp and hum and hum.Health > 0 then
                    local d = (hrp.Position - rootPos).Magnitude
                    if d < minD then minD, closest = d, model end
                end
            end
        end
    end
    return closest
end
local function getStand()
    local ch = player.Character
    if not ch then return nil end
    for _, child in ipairs(ch:GetChildren()) do
        if child:IsA("Model") and child:FindFirstChild("HumanoidRootPart") and child ~= ch then
            return child
        end
    end
    return nil
end
local activeAligns = {}
local currentTargetForEntity = {}
local function cleanupAlignFor(entity)
    if not entity then return end
    local hrp = entity:FindFirstChild("HumanoidRootPart")
    if hrp then
        for _, c in ipairs(hrp:GetChildren()) do
            if tostring(c.Name):match("^Stick_") then
                c:Destroy()
            end
        end
    end
    activeAligns[entity] = nil
    currentTargetForEntity[entity] = nil
end
local function createAlignsFor(entity, targetHRP, stickMode)
    if not entity or not targetHRP then return nil end
    cleanupAlignFor(entity)
    local hrp = entity:FindFirstChild("HumanoidRootPart")
    if not hrp then
        hrp = entity:FindFirstChild("Torso") or entity:FindFirstChild("UpperTorso")
    end
    if not hrp then
        local ok
        ok, hrp = pcall(function() return entity:WaitForChild("HumanoidRootPart", 0.5) end)
        if not ok then hrp = nil end
    end
    if not hrp then return nil end
    local offset = Vector3.new(0,0,0)
    if stickMode == "back" then
        offset = Vector3.new(0, BACK_HEIGHT, -BACK_DISTANCE)
    end
    local attA = Instance.new("Attachment")
    attA.Name = "Stick_AttA"
    attA.Parent = hrp
    attA.Position = Vector3.new(0,0,0)
    local attB = Instance.new("Attachment")
    attB.Name = "Stick_AttB"
    attB.Parent = targetHRP
    attB.Position = offset
    local alignPos = Instance.new("AlignPosition")
    alignPos.Name = "Stick_AlignPos"
    alignPos.Attachment0 = attA
    alignPos.Attachment1 = attB
    alignPos.MaxForce = ALIGN_MAX_FORCE
    alignPos.Responsiveness = ALIGN_RESPONSIVENESS
    alignPos.RigidityEnabled = false
    alignPos.Parent = hrp
    local alignOri = Instance.new("AlignOrientation")
    alignOri.Name = "Stick_AlignOri"
    alignOri.Attachment0 = attA
    alignOri.Attachment1 = attB
    alignOri.MaxTorque = ALIGN_MAX_FORCE
    alignOri.Responsiveness = ALIGN_RESPONSIVENESS
    alignOri.Parent = hrp
    activeAligns[entity] = {attA = attA, attB = attB, alignPos = alignPos, alignOri = alignOri, stickMode = stickMode}
    currentTargetForEntity[entity] = targetHRP
    if entity == player.Character then
        notify("Sticker", "Player align applied (mode="..tostring(stickMode)..")")
    end
    return activeAligns[entity]
end
local function smoothFallback(entity, targetHRP, stickMode, isAlive)
    local hrp = entity and entity:FindFirstChild("HumanoidRootPart")
    if not hrp or not targetHRP then return end
    local desiredPos
    if stickMode == "back" then
        desiredPos = targetHRP.Position - targetHRP.CFrame.LookVector * BACK_DISTANCE + Vector3.new(0, BACK_HEIGHT, 0)
    elseif stickMode == "Down" then
        local height = isAlive and -PLAYER_HEIGHT or PLAYER_HEIGHT
        desiredPos = targetHRP.Position + Vector3.new(0, height, 0)
    elseif stickMode == "Up" then
        local height = isAlive and PLAYER_HEIGHT or -PLAYER_HEIGHT
        desiredPos = targetHRP.Position + Vector3.new(0, height, 0)
    else
        return
    end
    local look = -Vector3.new(targetHRP.CFrame.LookVector.X, 0, targetHRP.CFrame.LookVector.Z).Unit
    local yaw = math.atan2(look.X, look.Z)
    local desiredCFrame = CFrame.new(desiredPos) * CFrame.Angles(0, yaw, 0)
    hrp.CFrame = hrp.CFrame:Lerp(desiredCFrame, SMOOTH_FALLBACK_ALPHA)
end
local viewing = false
local prevCameraSubject = nil
local prevCameraType = nil
local viewingStand = nil
-- orbit camera state & connections
local orbit = {
    yaw = 0,
    pitch = 0,
    radius = 8,
    minRadius = 2,
    maxRadius = 60,
    sensitivity = 0.0035,
    pitchMin = -math.pi/2 + 0.1,
    pitchMax = math.pi/2 - 0.1,
    dragging = false,
    inputChangedConn = nil,
    inputBeganConn = nil,
    inputEndedConn = nil,
    renderConn = nil
}
local function enableOrbitCamera(stand)
    if not stand or not stand:FindFirstChild("HumanoidRootPart") then
        notify("View Stand", "Can't view: stand missing HRP.")
        return
    end
    viewingStand = stand
    prevCameraSubject = camera.CameraSubject
    prevCameraType = camera.CameraType
    local standPos = stand.HumanoidRootPart.Position
    local camCF = camera.CFrame
    local toStand = (camCF.Position - standPos)
    orbit.radius = math.clamp(toStand.Magnitude, orbit.minRadius, orbit.maxRadius)
    local dir = toStand.Unit
    local pitch = math.asin(math.clamp(dir.Y, -1, 1)) * -1 -- invert so positive pitch raises camera
    local yaw = math.atan2(dir.X, dir.Z)
    orbit.yaw = yaw
    orbit.pitch = pitch
    camera.CameraType = Enum.CameraType.Scriptable
    orbit.inputBeganConn = UserInputService.InputBegan:Connect(function(input, processed)
        if processed then return end
        if input.UserInputType == Enum.UserInputType.MouseButton2 then
            orbit.dragging = true
            UserInputService.MouseIconEnabled = false
        end
    end)
    orbit.inputEndedConn = UserInputService.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton2 then
            orbit.dragging = false
            UserInputService.MouseIconEnabled = true
        end
    end)
    orbit.inputChangedConn = UserInputService.InputChanged:Connect(function(input, processed)
        if input.UserInputType == Enum.UserInputType.MouseMovement and orbit.dragging then
            orbit.yaw = orbit.yaw - input.Delta.X * orbit.sensitivity
            orbit.pitch = math.clamp(orbit.pitch - input.Delta.Y * orbit.sensitivity, orbit.pitchMin, orbit.pitchMax)
        elseif input.UserInputType == Enum.UserInputType.MouseWheel then
            orbit.radius = math.clamp(orbit.radius - input.Position.Z, orbit.minRadius, orbit.maxRadius)
        end
    end)
    orbit.renderConn = RunService.RenderStepped:Connect(function()
        if not viewing or not viewingStand or not viewingStand.Parent then return end
        local hrp = viewingStand:FindFirstChild("HumanoidRootPart")
        if not hrp then return end
        local standPos = hrp.Position
        local rot = CFrame.Angles(orbit.pitch, orbit.yaw, 0)
        local offset = rot:VectorToWorldSpace(Vector3.new(0, 0, orbit.radius))
        local camPos = standPos + offset
        camera.CFrame = CFrame.new(camPos, standPos)
    end)
    notify("View Stand", "Now viewing your stand")
    viewing = true
end
local function disableOrbitCamera()
    viewing = false
    viewingStand = nil
    if orbit.inputChangedConn then orbit.inputChangedConn:Disconnect() orbit.inputChangedConn = nil end
    if orbit.inputBeganConn then orbit.inputBeganConn:Disconnect() orbit.inputBeganConn = nil end
    if orbit.inputEndedConn then orbit.inputEndedConn:Disconnect() orbit.inputEndedConn = nil end
    if orbit.renderConn then orbit.renderConn:Disconnect() orbit.renderConn = nil end
    pcall(function()
        if prevCameraSubject then camera.CameraSubject = prevCameraSubject end
        if prevCameraType then camera.CameraType = prevCameraType end
    end)
    UserInputService.MouseIconEnabled = true
    notify("View Stand", "Camera restored.")
end
local function enableView(stand)
    if not stand or not stand:FindFirstChild("Humanoid") and not stand:FindFirstChild("HumanoidRootPart") then
        notify("View Stand", "Equipt your stand first")
        return
    end
    if viewing then return end
    enableOrbitCamera(stand)
end
local function disableView()
    if not viewing then return end
    disableOrbitCamera()
end
local stickerEnabled = false
local viewEnabled = false
local method = "normal"
local targetName = ""
TrollingTab:Section({Title = "Trolling"})
TrollingTab:Input({
    Flag = "TargetName",
    Title = "Enter Player/Mob Name",
    Callback = function(value)
        targetName = value
    end
})
TrollingTab:Space()
local stickerToggle = TrollingTab:Toggle({
    Flag = "Sticker",
    Title = "Sticker",
    Default = false,
    Callback = function(value)
        stickerEnabled = value
        if stickerEnabled then
            notify("YBA Script", "Sticker enabled for: ".. (targetName ~= "" and targetName or "<empty>"))
            if method == "Up" or method == "Down" then
                enableNoclip()
            end
        else
            notify("YBA Script", "Sticker disabled")
            for entity, _ in pairs(activeAligns) do cleanupAlignFor(entity) end
            disableNoclip()
        end
    end
})
TrollingTab:Space()
local viewToggle = TrollingTab:Toggle({
    Flag = "ViewStand",
    Title = "View Stand",
    Default = false,
    Callback = function(value)
        viewEnabled = value
        if value then
            local stand = getStand()
            if not stand then
                notify("View Stand", "Equipt your stand first")
                return
            end
            enableView(stand)
        else
            disableView()
        end
    end
})
TrollingTab:Space()
TrollingTab:Dropdown({
    Flag = "StickerMethod",
    Title = "Methods",
    Values = {"normal", "Down", "Up"},
    Value = "normal",
    Callback = function(option)
        method = option
        notify("YBA Script", "Method changed to: " .. method)
        -- Cleanup and reapply if enabled
        if stickerEnabled then
            for entity, _ in pairs(activeAligns) do cleanupAlignFor(entity) end
        end
        if method ~= "Down" and method ~= "Up" then
            disableNoclip()
        end
        if (method == "Down" or method == "Up") and stickerEnabled and not viewing then
            local stand = getStand()
            if stand then
                enableView(stand)
            end
        end
    end
})
TrollingTab:Space()
local flyEnabled = false
local flySpeed = 50
local flyBodyVelocity = nil
local flyBodyGyro = nil
local function enableFly()
    if flyEnabled then return end
    local char = player.Character
    if not char or not char:FindFirstChild("HumanoidRootPart") then return end
    local hrp = char.HumanoidRootPart
    flyBodyVelocity = Instance.new("BodyVelocity")
    flyBodyVelocity.Velocity = Vector3.new(0, 0, 0)
    flyBodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
    flyBodyVelocity.Parent = hrp
    flyBodyGyro = Instance.new("BodyGyro")
    flyBodyGyro.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
    flyBodyGyro.P = 100000
    flyBodyGyro.Parent = hrp
    flyEnabled = true
    notify("YBA Script", "Fly enabled.")
    spawn(function()
        while flyEnabled do
            if not char or not hrp then break end
            local moveDir = Vector3.new(0, 0, 0)
            if game:GetService("UserInputService"):IsKeyDown(Enum.KeyCode.W) then
                moveDir = moveDir + workspace.CurrentCamera.CFrame.LookVector
            end
            if game:GetService("UserInputService"):IsKeyDown(Enum.KeyCode.S) then
                moveDir = moveDir - workspace.CurrentCamera.CFrame.LookVector
            end
            if game:GetService("UserInputService"):IsKeyDown(Enum.KeyCode.A) then
                moveDir = moveDir - workspace.CurrentCamera.CFrame.RightVector
            end
            if game:GetService("UserInputService"):IsKeyDown(Enum.KeyCode.D) then
                moveDir = moveDir + workspace.CurrentCamera.CFrame.RightVector
            end
            if game:GetService("UserInputService"):IsKeyDown(Enum.KeyCode.Space) then
                moveDir = moveDir + Vector3.new(0, 1, 0)
            end
            if game:GetService("UserInputService"):IsKeyDown(Enum.KeyCode.LeftControl) then
                moveDir = moveDir - Vector3.new(0, 1, 0)
            end
            if moveDir.Magnitude > 0 then
                moveDir = moveDir.Unit * flySpeed
                flyBodyVelocity.Velocity = moveDir
                flyBodyGyro.CFrame = workspace.CurrentCamera.CFrame
            else
                flyBodyVelocity.Velocity = Vector3.new(0, 0, 0)
            end
            wait()
        end
    end)
end
local function disableFly()
    if not flyEnabled then return end
    if flyBodyVelocity then flyBodyVelocity:Destroy() end
    if flyBodyGyro then flyBodyGyro:Destroy() end
    flyEnabled = false
    notify("YBA Script", "Fly disabled.")
end
local flyToggle = TrollingTab:Toggle({
    Flag = "Fly",
    Title = "Enable Fly",
    Default = false,
    Callback = function(value)
        if value then
            enableFly()
        else
            disableFly()
        end
    end
})
TrollingTab:Space()
local lastFlySpeedNotify = 0
local flySpeedSlider = TrollingTab:Slider({
    Flag = "FlySpeed",
    Title = "Fly Speed",
    Step = 1,
    Value = {
        Min = 1,
        Max = 200,
        Default = 50,
    },
    Callback = function(value)
        flySpeed = value
        if os.clock() - lastFlySpeedNotify > 1 then
            notify("YBA Script", "Fly speed set to " .. value)
            lastFlySpeedNotify = os.clock()
        end
    end
})
RunService.Heartbeat:Connect(function(dt)
    scanTimer = scanTimer + dt
    if scanTimer >= CHECK_SCAN_INTERVAL then
        rebuildModelCache()
        scanTimer = 0
    end
    if viewing then
        if not viewingStand or not viewingStand.Parent or not viewingStand:FindFirstChild("HumanoidRootPart") then
            disableView()
        end
    end
    if not stickerEnabled then return end
    local name = targetName
    if not name or name == "" then return end
    local stand = getStand()
    if not stand then
        return
    end
    local target = findClosestByName(name)
    if not target then
        if next(activeAligns) ~= nil then
            notify("Sticker", "No alive target found (died?), turning off.")
            stickerToggle:Set(false)
            if viewEnabled then viewToggle:Set(false) end
            for entity,_ in pairs(activeAligns) do cleanupAlignFor(entity) end
        end
        return
    end
    local targetHRP = target:FindFirstChild("HumanoidRootPart")
    local targetHum = target:FindFirstChild("Humanoid")
    local isAlive = targetHum and targetHum.Health > 0
    if not targetHRP or not targetHum then
        for entity,_ in pairs(activeAligns) do cleanupAlignFor(entity) end
        if method == "Down" or method == "Up" then enableNoclip() else disableNoclip() end
        return
    end
    local myChar = player.Character
    if stand and currentTargetForEntity[stand] ~= targetHRP then
        local ok, res = pcall(createAlignsFor, stand, targetHRP, "back")
        if not ok or not res then
            cleanupAlignFor(stand)
        end
    end
    if method == "Down" or method == "Up" then
        if currentTargetForEntity[myChar] ~= targetHRP then
            local ok, res = pcall(createAlignsFor, myChar, targetHRP, method)
            if not ok or not res then
                cleanupAlignFor(myChar)
            end
        end
    else
        cleanupAlignFor(myChar)
        disableNoclip()
    end
    for entity, alignData in pairs(activeAligns) do
        if alignData and alignData.attB and alignData.attB.Parent == targetHRP then
            local desiredWorldPos
            if alignData.stickMode == "back" then
                desiredWorldPos = targetHRP.Position - targetHRP.CFrame.LookVector * BACK_DISTANCE + Vector3.new(0, BACK_HEIGHT, 0)
            elseif alignData.stickMode == "Down" then
                local height = isAlive and -PLAYER_HEIGHT or PLAYER_HEIGHT
                desiredWorldPos = targetHRP.Position + Vector3.new(0, height, 0)
            elseif alignData.stickMode == "Up" then
                local height = isAlive and PLAYER_HEIGHT or -PLAYER_HEIGHT
                desiredWorldPos = targetHRP.Position + Vector3.new(0, height, 0)
            end
            if desiredWorldPos then
                local localPos = targetHRP.CFrame:PointToObjectSpace(desiredWorldPos)
                alignData.attB.Position = localPos
            end
        else
            pcall(smoothFallback, entity, targetHRP, alignData.stickMode, isAlive)
        end
    end
    if (method == "Down" or method == "Up") and isAlive then
        enableNoclip()
    else
        if method ~= "Down" and method ~= "Up" then
            disableNoclip()
        end
    end
end)
player.CharacterRemoving:Connect(function()
    for entity,_ in pairs(activeAligns) do cleanupAlignFor(entity) end
    if viewing then disableView() end
    stickerToggle:Set(false)
    viewToggle:Set(false)
end)
player.CharacterAdded:Connect(function(ch)
    if noclipEnabled then
        spawn(function()
            local hrp = ch:WaitForChild("HumanoidRootPart", 5)
            if hrp then
                pcall(enableNoclip)
            end
        end)
    end
end)
local ConfigTab = SettingsTab
local ConfigManager = Window.ConfigManager
local ConfigName = "default"
local ConfigNameInput = ConfigTab:Input({
    Flag = "ConfigName",
    Title = "Config Name",
    Icon = "file-cog",
    Callback = function(value)
        ConfigName = value
    end
})
local AllConfigs = ConfigManager:AllConfigs()
local DefaultValue = table.find(AllConfigs, ConfigName) and ConfigName or nil
ConfigTab:Dropdown({
    Title = "All Configs",
    Desc = "Select existing configs",
    Values = AllConfigs,
    Value = DefaultValue,
    Callback = function(value)
        ConfigName = value
        ConfigNameInput:Set(value)
    end
})
ConfigTab:Space()
ConfigTab:Button({
    Title = "Save Config",
    Icon = "",
    Justify = "Center",
    Callback = function()
        Window.CurrentConfig = ConfigManager:CreateConfig(ConfigName)
        if Window.CurrentConfig:Save() then
            WindUI:Notify({
                Title = "Config Saved",
                Desc = "Config '" .. ConfigName .. "' saved",
                Icon = "check",
            })
        end
    end
})
ConfigTab:Space()
ConfigTab:Button({
    Title = "Load Config",
    Icon = "",
    Justify = "Center",
    Callback = function()
        Window.CurrentConfig = ConfigManager:CreateConfig(ConfigName)
        if Window.CurrentConfig:Load() then
            WindUI:Notify({
                Title = "Config Loaded",
                Desc = "Config '" .. ConfigName .. "' loaded",
                Icon = "refresh-cw",
            })
        end
    end
})
ConfigTab:Space()
local autoLoadToggle = ConfigTab:Toggle({
    Flag = "AutoLoad",
    Title = "Auto Load Script",
    Default = false
})
ConfigTab:Space()
ConfigTab:Dropdown({
    Title = "Theme Changer",
    Values = {"Dark", "Light", "Custom"},
    Callback = function(theme)
        notify("YBA Script", "Theme changed to " .. theme)
    end
})
ConfigTab:Space()
ConfigTab:Keybind({
    Flag = "ToggleKey",
    Title = "Keybind Changer",
    Default = Enum.KeyCode.K,
    Callback = function(key)
        Window:SetToggleKey(key)
        notify("YBA Script", "Toggle key changed to " .. key.Name)
    end
})
local defaultConfig = ConfigManager:CreateConfig("default")
defaultConfig:Load()
-- Ensure all features are off by default
tpToItemsToggle:Set(false)
autoSellMaxToggle:Set(false)
autoSellSelectedToggle:Set(false)
itemESPToggle:Set(false)
playerESPToggle:Set(false)
itemNotifierToggle:Set(false)
showTopBarToggle:Set(false)
antiAFKToggle:Set(false)
fpsBoosterToggle:Set(false)
instantPickupToggle:Set(false)
afkCameraToggle:Set(false)
autoLoadToggle:Set(false)
notify("YBA Script", "Script loaded successfully.")
local TeleportService = game:GetService("TeleportService")
spawn(function()
    while true do
        wait(1)
        pcall(function()
            local coreGui = game:GetService("CoreGui")
            local prompt = coreGui:FindFirstChild("RobloxPromptGui")
            if prompt then
                local overlay = prompt:FindFirstChild("promptOverlay")
                if overlay then
                    local errorPrompt = overlay:FindFirstChild("ErrorPrompt")
                    if errorPrompt and errorPrompt.Visible then
                        local titleFrame = errorPrompt:FindFirstChild("TitleFrame")
                        if titleFrame then
                            local errorTitle = titleFrame:FindFirstChild("ErrorTitle")
                            if errorTitle and (string.lower(errorTitle.Text):find("disconnect") or string.lower(errorTitle.Text):find("kicked")) then
                                notify("YBA Script", "Detected kick/disconnect. Rejoining the server...")
                                TeleportService:TeleportToPlaceInstance(game.PlaceId, game.JobId)
                            end
                        end
                    end
                end
            end
        end)
    end
end)
